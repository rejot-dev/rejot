import type {
  IDataSource,
  IDataSink,
  Transaction,
  TableOperation,
  PublicSchemaOperation,
} from "./source-sink-protocol.ts";
import logger from "./logger.ts";
import { BACKFILL_TIMEOUT_SECONDS } from "./const.ts";

const log = logger.createLogger("sync-controller");

type SyncControllerConfig = {
  source: IDataSource;
  sink: IDataSink;
};

type ResultSetKey = string;

type BackfillWatermark = {
  type: "low" | "high";
  backfillId: string;
};

export function getResultSetKey(operation: TableOperation | PublicSchemaOperation): ResultSetKey {
  if (operation.type === "delete") {
    throw new Error("Delete operations are not supported yet");
  }
  const columnValues = operation.keyColumns
    .sort()
    .map((column) => `${column}=${operation.new[column]}`);
  return columnValues.join(",");
}

export function getKeyColumns(resultSetKey: ResultSetKey): string[] {
  return resultSetKey.split(",").map((column) => column.split("=")[0]);
}

export function watermarkFromTransaction(transaction: Transaction): BackfillWatermark | null {
  for (const operation of transaction.operations) {
    if (
      operation.type === "insert" &&
      operation.table === "watermarks" &&
      operation.tableSchema == "rejot"
    ) {
      const watermark = operation.new.type;
      if (watermark === "low" || watermark === "high") {
        return {
          type: watermark,
          backfillId: operation.new.backfill as string,
        };
      } else {
        throw new Error(`Unknown watermark type: ${watermark}`);
      }
    }
  }
  return null;
}

function recordToPublicSchemaOperation(
  keyColumns: string[],
  record: Record<string, unknown>,
): PublicSchemaOperation {
  return {
    type: "insert",
    keyColumns: keyColumns,
    new: record,
  };
}

export class SyncController {
  #source: IDataSource;
  #sink: IDataSink;

  #backfillLowMarkerSeen: boolean = false;
  #currentBackfillId?: string;
  #currentBackfillStartTime?: Date;

  #resultSet: Map<ResultSetKey, Record<string, unknown>> = new Map();
  #dropSet: Set<ResultSetKey> = new Set();

  constructor({ source, sink }: SyncControllerConfig) {
    this.#source = source;
    this.#sink = sink;
  }

  async start(): Promise<void> {
    log.info("Initializing sync process...");

    // Connect to source and sink
    await this.#source.prepare();
    await this.#sink.prepare();

    // Start listening for changes
    await this.#source.subscribe(this.#processTransaction.bind(this));
  }

  async stop(): Promise<void> {
    try {
      await this.#source.stop();
    } catch (error) {
      log.error("Error stopping source:", error);
    }
    try {
      await this.#sink.stop();
    } catch (error) {
      log.error("Error stopping sink:", error);
    }
  }

  async flushResultSet(): Promise<void> {
    let flushCount = 0;
    for (const [key, record] of this.#resultSet) {
      if (this.#dropSet.has(key)) {
        continue;
      }
      const operation = recordToPublicSchemaOperation(getKeyColumns(key), record);
      await this.#sink.writeData(operation);
      flushCount++;
    }
    log.info(
      `Flushed ${flushCount}/${this.#resultSet.size} records to sink, ${this.#resultSet.size - flushCount} records were stale`,
    );
    this.#resultSet.clear();
    this.#dropSet.clear();
  }

  async #processTransaction(transaction: Transaction): Promise<boolean> {
    // This implementation follows the dblog watermark algorithm as described here:
    // https://netflixtechblog.com/dblog-a-generic-change-data-capture-framework-69351fb9099b
    log.info(
      `Processing transaction ${transaction.id} with ${transaction.operations.length} operation(s).`,
    );

    const watermark = watermarkFromTransaction(transaction);

    if (watermark) {
      if (!this.#currentBackfillId || this.#currentBackfillId !== watermark.backfillId) {
        // The marker we observe here was not generated by this sync controller,
        // this transaction could be from previous sync controller runs that failed during backfill
        log.warn(
          `Found ${watermark.type} marker for unknown backfill ${watermark.backfillId}, ignoring marker`,
        );
        return true;
      }

      if (watermark.type === "low") {
        this.#backfillLowMarkerSeen = true;
      } else {
        this.#backfillLowMarkerSeen = false;
        await this.flushResultSet();
      }
      log.trace(
        `Backfill ${watermark.type} watermark received: ${transaction.id} for backfill ${watermark.backfillId}`,
      );
      return true; // Acknowledge watermark and continue
    }

    if (this.#backfillLowMarkerSeen) {
      // Any writes happening to records during the backfill will be applied normally but must be
      // dropped from the backfill result set, to prevent backfill records from overwriting newer records in the destination
      for (const operation of transaction.operations) {
        const key = getResultSetKey(operation);
        this.#dropSet.add(key);
      }

      // Check here for backfill timeout
      if (this.#currentBackfillStartTime) {
        const backfillDuration = new Date().getTime() - this.#currentBackfillStartTime.getTime();
        if (backfillDuration > BACKFILL_TIMEOUT_SECONDS) {
          log.warn(
            `Backfill ${this.#currentBackfillId} timed out after ${BACKFILL_TIMEOUT_SECONDS} seconds`,
          );
          this.#backfillLowMarkerSeen = false;
          this.#dropSet.clear();
          this.#currentBackfillId = undefined;
        }
      }
    }

    for (const operation of transaction.operations) {
      const transformedData = await this.#source.applyTransformations(operation);
      if (transformedData) {
        await this.#sink.writeData(transformedData);
      } else {
        throw new Error("No transformed data for operation");
      }
    }

    return true;
  }

  async startBackfill(sql: string, keyColumns: string[], values?: unknown[]): Promise<string> {
    if (this.#backfillLowMarkerSeen) {
      throw new Error("Starting new backfill while we haven't completed a previous one!");
    }

    const backfillId = crypto.randomUUID();

    log.info(`Starting backfill ${backfillId}`);
    this.#currentBackfillId = backfillId;
    this.#currentBackfillStartTime = new Date();

    await this.#source.writeWatermark("low", backfillId);

    const result = await this.#source.getBackfillRecords(sql, values);

    this.#resultSet = new Map(
      result.map((row) => [getResultSetKey(recordToPublicSchemaOperation(keyColumns, row)), row]),
    );
    log.debug(`Fetched ${result.length} records for backfill ${backfillId}`);
    await this.#source.writeWatermark("high", backfillId);
    return backfillId;
  }
}
