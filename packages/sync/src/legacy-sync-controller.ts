import crypto from "node:crypto";

import { getLogger } from "@rejot-dev/contract/logger";
import type {
  IDataSink,
  IDataSource,
  Transaction,
  TransformedOperation,
} from "@rejot-dev/contract/sync";

import { type BackfillSource, ResultSetStore } from "./result-set-store.ts";
import { DEFAULT_BACKFILL_TIMEOUT_MS } from "./sync-consts.ts";

// TODO(Wilco): This should be removed, but it has an implementation for backfills we still need to port.

const log = getLogger(import.meta.url);

type SyncControllerConfig = {
  source: IDataSource;
  sink: IDataSink;
  backfillTimeoutMs?: number;
};

type BackfillWatermark = {
  type: "low" | "high";
  backfillId: string;
};

export function watermarkFromTransaction(transaction: Transaction): BackfillWatermark | null {
  for (const operation of transaction.operations) {
    if (operation.type === "insert" && operation.table === "watermarks") {
      const watermark = operation.new["type"];
      if (watermark === "low" || watermark === "high") {
        return {
          type: watermark,
          backfillId: operation.new["backfill"] as string,
        };
      } else {
        throw new Error(`Unknown watermark type: ${watermark}`);
      }
    }
  }
  return null;
}

function recordToPublicSchemaOperation(record: Record<string, unknown>): TransformedOperation {
  return {
    type: "insert",
    object: record,
    sourceManifestSlug: "legacy-sync-controller",
    sourcePublicSchema: {
      name: "legacy-sync-controller",
      version: {
        major: 1,
        minor: 0,
      },
    },
  };
}

export class LegacySyncController {
  #source: IDataSource;
  #sink: IDataSink;

  #backfillLowMarkerSeen: boolean = false;
  #currentBackfillId?: string;
  #currentBackfillStartTime?: Date;

  #resultSet: ResultSetStore = new ResultSetStore();

  #ready: boolean = false;
  #backfillTimeoutMs: number = DEFAULT_BACKFILL_TIMEOUT_MS;

  constructor({ source, sink, backfillTimeoutMs }: SyncControllerConfig) {
    this.#source = source;
    this.#sink = sink;

    if (backfillTimeoutMs) {
      this.#backfillTimeoutMs = backfillTimeoutMs;
    }
  }

  async prepare(): Promise<void> {
    if (this.#ready) {
      return;
    }
    await Promise.all([this.#source.prepare(), this.#sink.prepare()]);
    this.#ready = true;
  }

  async start(): Promise<void> {
    if (!this.#ready) {
      throw new Error("Sync Controller is not ready, call prepare() first.");
    }

    log.info("Initializing sync process...");
    // Start listening for changes
    await this.#source.subscribe(this.#processTransaction.bind(this));
  }

  async stop(): Promise<void> {
    try {
      await Promise.all([this.#source.stop(), this.#sink.close()]);
    } catch (error) {
      log.error("Error stopping source or sink:", error);
    }
  }

  async #flushResultSet(): Promise<void> {
    let flushCount = 0;
    for (const [_keyColumns, record] of this.#resultSet.getRecordsWithoutDropKeys()) {
      const operation = recordToPublicSchemaOperation(record);
      await this.#sink.writeData(operation);
      flushCount++;
    }
    log.info(
      `Flushed ${flushCount}/${this.#resultSet.size()} records to sink, ${this.#resultSet.size() - flushCount} records were stale`,
    );
    this.#resultSet.clear();
  }

  async #processTransaction(transaction: Transaction): Promise<boolean> {
    // This implementation follows the dblog watermark algorithm as described here:
    // https://netflixtechblog.com/dblog-a-generic-change-data-capture-framework-69351fb9099b
    log.info(
      `Processing transaction ${transaction.id} with ${transaction.operations.length} operation(s).`,
    );

    const watermark = watermarkFromTransaction(transaction);

    if (watermark) {
      if (!this.#currentBackfillId || this.#currentBackfillId !== watermark.backfillId) {
        // The marker we observe here was not generated by this sync controller,
        // this transaction could be from previous sync controller runs that failed during backfill
        log.warn(
          `Found ${watermark.type} marker for unknown backfill ${watermark.backfillId}, ignoring marker`,
        );
        return true;
      }

      if (watermark.type === "low") {
        this.#backfillLowMarkerSeen = true;
      } else {
        // Is high, so we've completed the backfill
        // Push all records to the sink, that we have not seen in the previous transactions.
        this.#backfillLowMarkerSeen = false;
        await this.#flushResultSet();
      }
      log.trace(
        `Backfill ${watermark.type} watermark received: ${transaction.id} for backfill ${watermark.backfillId}`,
      );
      return true; // Acknowledge watermark and continue
    }

    if (this.#backfillLowMarkerSeen) {
      // Any writes happening to records during the backfill will be applied normally but must be
      // dropped from the backfill result set, to prevent backfill records from overwriting newer records in the destination
      for (const operation of transaction.operations) {
        this.#resultSet.addDropKey(operation);
      }

      // Check here for backfill timeout
      if (this.#currentBackfillStartTime) {
        const backfillDurationMs = new Date().getTime() - this.#currentBackfillStartTime.getTime();
        if (backfillDurationMs > this.#backfillTimeoutMs) {
          log.warn(
            `Backfill ${this.#currentBackfillId} timed out after ${this.#backfillTimeoutMs} ms`,
          );
          this.#backfillLowMarkerSeen = false;
          this.#resultSet.clear();
          this.#currentBackfillId = undefined;
        }
      }
    }

    for (const operation of transaction.operations) {
      const transformedData = await this.#source.applyTransformations(operation);
      if (transformedData) {
        await this.#sink.writeData(transformedData);
      } else {
        throw new Error("No transformed data for operation");
      }
    }

    return true;
  }

  async startBackfill(
    sourceTables: BackfillSource[],
    sql: string,
    values?: unknown[],
  ): Promise<string> {
    if (this.#backfillLowMarkerSeen) {
      throw new Error("Starting new backfill while we haven't completed a previous one!");
    }
    if (!this.#ready) {
      throw new Error(
        "Sync controller not ready, a replication slot must have been created before starting backfill process.",
      );
    }

    const backfillId = crypto.randomUUID();

    log.info(`Starting backfill ${backfillId}`);
    this.#currentBackfillId = backfillId;
    this.#currentBackfillStartTime = new Date();

    await this.#source.writeWatermark("low", backfillId);

    const result = await this.#source.getBackfillRecords(sql, values);

    this.#resultSet.addRecords(sourceTables, result);
    log.debug(`Fetched ${result.length} records for backfill ${backfillId}`);

    await this.#source.writeWatermark("high", backfillId);
    return backfillId;
  }
}
