---
description: When working in the controller appt
globs: apps/controller/**
---

# Controller App

## Overview
- This is a Bun/NodeJS app.
- We use a standard flow: `x.routes.ts` -> `x.service.ts` -> `x.repository.ts`
- For external API calls, use `x.api-client.ts`

## Dependency Injection
- Uses `npm:typed-inject`
- Injection context defined in [injector.ts](mdc:apps/controller/src/injector.ts)
- Key principles:
  - Use interfaces for injectables
  - Classes inject other classes
  - All injectable classes (with `static inject`) must be added to `injector.ts`

Example injectable class with authentication:
```ts
import { tokens } from "typed-inject";
import { createRoute } from "@hono/zod-openapi";
import type { IAuthenticationMiddleware } from "@/authentication/authentication.middleware.ts";

export interface IMyService {
  createThing(thing: Thing): Promise<ThingEntity>;
}

export class ExampleRoutes {
  static inject = tokens("myService", "authenticationMiddleware");

  #routes;

  constructor(
    myService: IMyService,
    authenticationMiddleware: IAuthenticationMiddleware,
  ) {
    this.#routes = new OpenAPIHono()
      .openapi(
        createRoute({
          ...myThingCreateApi,
          middleware: [authenticationMiddleware.requireLogin()] as const,
        }),
        async (c) => {
          const { organizationId } = c.req.valid("param");
          const clerkUserId = c.get("clerkUserId");
          await authenticationMiddleware.requireOrganizationAccess(clerkUserId, organizationId);

          const thing = c.req.valid("json");
          const result = await myService.createThing(thing);
          return c.json(result, 201);
        },
      );
  }

  get routes() {
    return this.#routes;
  }
}
```

### Identifiers (ids) and codes
- Use generated codes instead of UUIDs
- Codes are generated by [codes.ts](mdc:apps/controller/src/codes/codes.ts)
- API exposes codes as "ids"
- Internal DB schema:
  - `code` as string
  - `id` as number (private primary key)
- The string variant is called 'id' everywhere EXPECT in repositories.

## Database & ORM
### Drizzle Usage
- Drizzle is used as ORM/Query Builder
- One Typescript method in a repository class should generally have ONE Postgres query. Having multiple ones is only allowed for very complex write operations.
- If a query is complicated, first write the query in pure Postgres. Then rewrite with Drizzle's query builder.
- Use CTEs with `with` and `$with` as needed
- Schema defined in [schema.ts](mdc:apps/controller/src/postgres/schema.ts)
- In repositories BE VERY MINDFUL about ids and codes. Usually we are only handed a string (code) from the API, the query is responsible for getting the assoicated id.

### Repository Pattern
Example repository:
```ts
import { tokens } from "typed-inject";
import type { PostgresManager } from "@/postgres/postgres.ts";

export interface ISomeRepository {
  // ...
}

export class SomeRepository implements ISomeRepository {
  static inject = tokens("postgres");

  #db: PostgresManager["db"];

  constructor(postgres: PostgresManager) {
    this.#db = postgres.db;
  }

  async createThing(someCode: string): Promise<Thing> {
    const org = this.#db.$with("org").as(
      this.#db
        .select({
          id: schema.organization.id,
          code: schema.organization.code,
          name: schema.organization.name,
        })
        .from(schema.organization)
        .where(eq(schema.organization.code, someCode)),
    );
    const res = await this.#db
      .with(org)
      .insert(schema.organization).values({
        organizationId: sql`SELECT id FROM org`,
        // ...
      }).returning({
        // ...
      });
  }
}
```

## API Development
### OpenAPI Specification
- Create OpenAPI spec first in `packages/api-interface-controller`
- Always implement both route AND api files (`<domain>.api.ts` and `<domain>.routes.ts`)
- Add `*.api.ts` files to relevant `package.json` exports
- Import using `@rejot/api-interface-controller/<file>`

Example API definition:
```ts
import { type RouteConfig, z } from "@hono/zod-openapi";

export const OrganizationGetResponseSchema = z.object({
  // ..
}).openapi("Organization");

// PREFER to import this type instead of inferring from Zod
export type Organization = {
  // .. (MAKE SURE this matches schema above)
}

export const organizationGetApi = {
  method: "get",
  path: "/organizations/{organizationId}",
  request: {
    params: z.object({
      organizationId: z.string(),
    }),
  },
  responses: {
    200: {
      content: {
        "application/json": {
          schema: OrganizationGetResponse,
        },
      },
      description: "Organization retrieved successfully",
    },
    400: {
      description: "Invalid request body",
      content: {
        "application/json": {
          schema: ZodErrorSchema,
        },
      },
    },
    404: {
      description: "Organization not found",
    },
    500: {
      description: "Internal server error",
    },
  },
  tags: ["organizations"],
  description: "Get an organization by code",
} satisfies RouteConfig;
```

## Authentication
### Route Authentication
- All routes should require authentication using `authenticationMiddleware`
- Two levels of authentication:
  1. Login check: `authenticationMiddleware.requireLogin()`
  2. Organization access: `authenticationMiddleware.requireOrganizationAccess(clerkUserId, organizationId)`
- Always add both in this order:
  ```ts
  .openapi(
    createRoute({
      ...someApi,
      middleware: [authenticationMiddleware.requireLogin()] as const,
    }),
    async (c) => {
      const { organizationId } = c.req.valid("param");
      const clerkUserId = c.get("clerkUserId");
      await authenticationMiddleware.requireOrganizationAccess(clerkUserId, organizationId);
      // ... rest of the route handler
    }
  )
  ```

## Error Handling
- Each domain has its own `<domain>.error.ts`
- Extends from [base-error.ts](mdc:apps/controller/src/error/base-error.ts)

Example error definition:
```ts
import { BaseError, type ErrorDefinition, type ErrorMap } from "@/error/base-error.ts";

export type ClerkErrorCode =
  | "CLERK_USER_NOT_FOUND"
  | "CLERK_USER_INCOMPLETE_PROFILE";

export type ClerkErrorContext = {
  clerkUserId?: string;
  missingFields?: string[];
};

export const ClerkErrors = {
  USER_NOT_FOUND: {
    code: "CLERK_USER_NOT_FOUND",
    message: "User not found",
    httpStatus: 404,
  },
  INCOMPLETE_PROFILE: {
    code: "CLERK_USER_INCOMPLETE_PROFILE",
    message: "User has incomplete profile information",
    httpStatus: 400,
  },
} as const satisfies ErrorMap<ClerkErrorCode, ClerkErrorContext>;

export class ClerkError extends BaseError<ClerkErrorCode, ClerkErrorContext> {
  constructor(definition: ErrorDefinition<ClerkErrorCode, ClerkErrorContext>) {
    super(definition);
  }
}
```

## Testing
- For database queries, use `dbDescribe`
  - Import: `import { dbDescribe } from "@/postgres/db-test.ts";`
  - Opens transaction and rolls back after test
- Use `import { test, describe, ... } from "bun:test";` for assertions in tests 

## TypeScript Guidelines
### Code Style
- Use Javascript private (#) for private members
- Always use `import type` and indicate `type` as needed
- Always use curly braces, even for single-line blocks
- Use `T[]` instead of `Array<T>`
- Avoid:
  - Enums
  - Constructor parameter members
  - TypeScript constructs that don't work with type stripping
- NEVER use Unsafe type casting unless EXPLICITELY asked for.

