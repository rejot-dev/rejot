---
description: When working in the controller appt
globs: apps/controller/**
---

# Controller App

## Overview
- This is a Bun/NodeJS app.
- We use a standard flow: `x.routes.ts` -> `x.service.ts` -> `x.repository.ts`
- For external API calls, use `x.api-client.ts`

## Dependency Injection
- Uses `npm:typed-inject`
- Injection context defined in [injector.ts](mdc:apps/controller/src/injector.ts)
- Key principles:
  - Use interfaces for injectables
  - Classes inject other classes
  - All injectable classes (with `static inject`) must be added to `injector.ts`

Example injectable class with authentication:
```ts
import { tokens } from "typed-inject";
import { createRoute } from "@hono/zod-openapi";
import type { IAuthenticationMiddleware } from "@/authentication/authentication.middleware.ts";

export interface IMyService {
  createThing(thing: Thing): Promise<ThingEntity>;
}

export class ExampleRoutes {
  static inject = tokens("myService", "authenticationMiddleware");

  #routes;

  constructor(
    myService: IMyService,
    authenticationMiddleware: IAuthenticationMiddleware,
  ) {
    this.#routes = new OpenAPIHono()
      .openapi(
        createRoute({
          ...myThingCreateApi,
          middleware: [authenticationMiddleware.requireLogin()] as const,
        }),
        async (c) => {
          const { organizationId } = c.req.valid("param");
          const clerkUserId = c.get("clerkUserId");
          await authenticationMiddleware.requireOrganizationAccess(clerkUserId, organizationId);

          const thing = c.req.valid("json");
          const result = await myService.createThing(thing);
          return c.json(result, 201);
        },
      );
  }

  get routes() {
    return this.#routes;
  }
}
```

## Database & ORM
### Drizzle Usage
- Drizzle is used as ORM/Query Builder
- One Typescript method = One SQL query
- Design queries in pure Postgres first, then create Drizzle version
- Use CTEs with `with` and `$with` as needed
- Schema defined in [schema.ts](mdc:apps/controller/src/postgres/schema.ts)

### ID Management
- Use generated codes instead of UUIDs
- Codes are generated by [codes.ts](mdc:apps/controller/src/codes/codes.ts)
  - Max 30 characters
  - Start with 3/4 letters as prefix
  - Generated in service layer
- API exposes codes as "ids"
- Internal DB schema:
  - `code` as string
  - `id` as number (private primary key)

### Repository Pattern
Example repository:
```ts
import { tokens } from "typed-inject";
import type { PostgresManager } from "@/postgres/postgres.ts";

export interface IClerkRepository {
  // ...
}

export class ClerkRepository implements IClerkRepository {
  static inject = tokens("postgres");

  #db: PostgresManager["db"];

  constructor(postgres: PostgresManager) {
    this.#db = postgres.db;
  }

  async createThing(params: { clerkUserId: string }): Promise<{
    clerkUserId: string;
    createdAt: Date;
  }> {
    const res = await this.#db.insert(schema.organization).values({
      // ...
    }).returning({
      // ...
    });
  }
}
```

## API Development
### OpenAPI Specification
- Create OpenAPI spec first in `packages/api-interface-controller`
- Always implement both route AND api files (`<domain>.api.ts` and `<domain>.routes.ts`)
- Add `*.api.ts` files to relevant `package.json` exports
- Import using `@rejot/api-interface-controller/<file>`

Example API definition:
```ts
import { type RouteConfig, z } from "@hono/zod-openapi";

export const OrganizationGetResponseSchema = z.object({
  // ..
}).openapi("Organization");

// PREFER to import this type instead of inferring from Zod
export type Organization = {
  // .. (MAKE SURE this matches schema above)
}

export const organizationGetApi = {
  method: "get",
  path: "/{organizationCode}",
  request: {
    params: z.object({
      organizationCode: z.string(),
    }),
  },
  responses: {
    200: {
      content: {
        "application/json": {
          schema: OrganizationGetResponse,
        },
      },
      description: "Organization retrieved successfully",
    },
    404: {
      description: "Organization not found",
    },
    500: {
      description: "Internal server error",
    },
  },
  tags: ["organizations"],
  description: "Get an organization by code",
} satisfies RouteConfig;
```

## Authentication
### Route Authentication
- All routes should require authentication using `authenticationMiddleware`
- Two levels of authentication:
  1. Login check: `authenticationMiddleware.requireLogin()`
  2. Organization access: `authenticationMiddleware.requireOrganizationAccess(clerkUserId, organizationId)`
- Always add both in this order:
  ```ts
  .openapi(
    createRoute({
      ...someApi,
      middleware: [authenticationMiddleware.requireLogin()] as const,
    }),
    async (c) => {
      const { organizationId } = c.req.valid("param");
      const clerkUserId = c.get("clerkUserId");
      await authenticationMiddleware.requireOrganizationAccess(clerkUserId, organizationId);
      // ... rest of the route handler
    }
  )
  ```

## Error Handling
- Each domain has its own `<domain>.error.ts`
- Extends from [base-error.ts](mdc:apps/controller/src/error/base-error.ts)

Example error definition:
```ts
import { BaseError, type ErrorDefinition, type ErrorMap } from "@/error/base-error.ts";

export type ClerkErrorCode =
  | "CLERK_USER_NOT_FOUND"
  | "CLERK_USER_INCOMPLETE_PROFILE";

export type ClerkErrorContext = {
  clerkUserId?: string;
  missingFields?: string[];
};

export const ClerkErrors = {
  USER_NOT_FOUND: {
    code: "CLERK_USER_NOT_FOUND",
    message: "User not found",
    httpStatus: 404,
  },
  INCOMPLETE_PROFILE: {
    code: "CLERK_USER_INCOMPLETE_PROFILE",
    message: "User has incomplete profile information",
    httpStatus: 400,
  },
} as const satisfies ErrorMap<ClerkErrorCode, ClerkErrorContext>;

export class ClerkError extends BaseError<ClerkErrorCode, ClerkErrorContext> {
  constructor(definition: ErrorDefinition<ClerkErrorCode, ClerkErrorContext>) {
    super(definition);
  }
}
```

## Testing
- For database queries, use `dbTest`
  - Import: `import { dbTest } from "@/postgres/db-test.ts";`
  - Opens transaction and rolls back after test
- Wireframe/outline creation doesn't require placeholder repository queries
- Use `import { assert, assertEquals, assertMatch } from "@std/assert";` for assertions in tests 

## TypeScript Guidelines
### Code Style
- Use Javascript private (#) for private members
- Always use `import type` and indicate `type` as needed
- Always use curly braces, even for single-line blocks
- Use `T[]` instead of `Array<T>`
- Avoid:
  - Enums
  - Constructor parameter members
  - TypeScript constructs that don't work with type stripping

